<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Spherical Grid</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1E1E2E;
            perspective: 800px;
            overflow: hidden;
        }
        
        .grid-container {
            position: relative;
            width: 600px;
            height: 300px;
            border: 1px solid rgba(92, 187, 246, 0.2);
            overflow: hidden;
            background-color: rgba(24, 24, 37, 0.8);
            transform-style: preserve-3d;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        
        .grid-line {
            position: absolute;
            background-color: rgba(92, 187, 246, 0.3);
            transition: transform 0.2s ease, background-color 0.2s ease;
            transform-style: preserve-3d;
        }
        
        .horizontal-line {
            width: 100%;
            height: 1px;
        }
        
        .vertical-line {
            width: 1px;
            height: 100%;
        }
        
        .grid-line.active {
            background-color: rgba(255, 95, 86, 0.6);
            box-shadow: 0 0 5px rgba(255, 95, 86, 0.3);
        }
        
        .grid-segment {
            position: absolute;
            transition: all 0.2s ease;
            transform-style: preserve-3d;
        }
        
        .horizontal-segment {
            height: 1px;
        }
        
        .vertical-segment {
            width: 1px;
        }
        
        .grid-segment.elevated {
            box-shadow: 0 0 8px rgba(255, 95, 86, 0.7);
        }
    </style>
</head>
<body>
    <div class="grid-container" id="gridContainer">
        <!-- Le linee e i segmenti verranno generati via JavaScript -->
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const gridContainer = document.getElementById('gridContainer');
            
            // Configurazione
            const lineSpacing = 15; // Spazio tra le linee (ridotto per maggiore densità)
            const influenceRadius = 100; // Raggio di influenza del mouse (aumentato)
            const maxElevation = 60; // Elevazione massima in pixel (asse Z) (aumentata)
            const segmentsPerLine = 40; // Numero di segmenti per linea (aumentato)
            const maxLineThickness = 4; // Spessore massimo delle linee (nuovo)
            
            let horizontalLines = [];
            let verticalLines = [];
            let gridWidth, gridHeight;
            let isMouseOver = false;
            
            // Funzione per creare la griglia
            function createGrid() {
                // Pulisci la griglia esistente
                gridContainer.innerHTML = '';
                horizontalLines = [];
                verticalLines = [];
                
                // Ottieni le dimensioni del contenitore
                gridWidth = gridContainer.clientWidth;
                gridHeight = gridContainer.clientHeight;
                
                // Calcola il numero di linee orizzontali e verticali
                const numHorizontalLines = Math.floor(gridHeight / lineSpacing) + 1;
                const numVerticalLines = Math.floor(gridWidth / lineSpacing) + 1;
                
                // Crea le linee orizzontali e i loro segmenti
                for (let i = 0; i < numHorizontalLines; i++) {
                    const y = i * lineSpacing;
                    const lineContainer = document.createElement('div');
                    lineContainer.className = 'grid-line horizontal-line';
                    lineContainer.style.top = `${y}px`;
                    
                    const segments = [];
                    const segmentWidth = gridWidth / segmentsPerLine;
                    
                    for (let j = 0; j < segmentsPerLine; j++) {
                        const segment = document.createElement('div');
                        segment.className = 'grid-segment horizontal-segment';
                        segment.style.width = `${segmentWidth}px`;
                        segment.style.left = `${j * segmentWidth}px`;
                        segment.style.top = '0';
                        segment.style.backgroundColor = 'rgba(92, 187, 246, 0.3)';
                        
                        lineContainer.appendChild(segment);
                        
                        segments.push({
                            element: segment,
                            x: j * segmentWidth + segmentWidth / 2,
                            y: y,
                            width: segmentWidth,
                            originalY: y
                        });
                    }
                    
                    gridContainer.appendChild(lineContainer);
                    
                    horizontalLines.push({
                        element: lineContainer,
                        y: y,
                        segments: segments
                    });
                }
                
                // Crea le linee verticali e i loro segmenti
                for (let i = 0; i < numVerticalLines; i++) {
                    const x = i * lineSpacing;
                    const lineContainer = document.createElement('div');
                    lineContainer.className = 'grid-line vertical-line';
                    lineContainer.style.left = `${x}px`;
                    
                    const segments = [];
                    const segmentHeight = gridHeight / segmentsPerLine;
                    
                    for (let j = 0; j < segmentsPerLine; j++) {
                        const segment = document.createElement('div');
                        segment.className = 'grid-segment vertical-segment';
                        segment.style.height = `${segmentHeight}px`;
                        segment.style.top = `${j * segmentHeight}px`;
                        segment.style.left = '0';
                        segment.style.backgroundColor = 'rgba(92, 187, 246, 0.3)';
                        
                        lineContainer.appendChild(segment);
                        
                        segments.push({
                            element: segment,
                            x: x,
                            y: j * segmentHeight + segmentHeight / 2,
                            height: segmentHeight,
                            originalX: x
                        });
                    }
                    
                    gridContainer.appendChild(lineContainer);
                    
                    verticalLines.push({
                        element: lineContainer,
                        x: x,
                        segments: segments
                    });
                }
            }
            
            // Funzione per calcolare l'elevazione sferica esagerata
            function calculateSphericalElevation(dx, dy, distance, radius) {
                if (distance >= radius) return 0;
                
                // Formula migliorata per una superficie sferica più esagerata
                const normalizedDistance = distance / radius;
                // Utilizziamo una funzione coseno modificata per un effetto più pronunciato
                const elevationFactor = Math.pow(Math.cos(normalizedDistance * Math.PI / 2), 1.5);
                return maxElevation * elevationFactor;
            }
            
            // Funzione per calcolare lo spessore della linea in base all'elevazione
            function calculateLineThickness(elevation) {
                // Spessore proporzionale all'elevazione
                return 1 + (maxLineThickness - 1) * (elevation / maxElevation);
            }
            
            // Funzione per deformare le linee in modo sferico esagerato
            function deformLines(mouseX, mouseY) {
                // Resetta tutte le linee se il mouse non è sopra il contenitore
                if (!isMouseOver) {
                    handleMouseLeave();
                    return;
                }
                
                // Deforma i segmenti orizzontali
                horizontalLines.forEach(line => {
                    let isLineActive = false;
                    
                    line.segments.forEach(segment => {
                        const dx = mouseX - segment.x;
                        const dy = mouseY - segment.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < influenceRadius) {
                            const elevation = calculateSphericalElevation(dx, dy, distance, influenceRadius);
                            const thickness = calculateLineThickness(elevation);
                            
                            // Applica la trasformazione 3D con spessore aumentato
                            segment.element.style.transform = `translateZ(${elevation}px)`;
                            segment.element.style.height = `${thickness}px`;
                            segment.element.style.marginTop = `-${(thickness-1)/2}px`; // Centra la linea più spessa
                            
                            // Colore più intenso e luminoso
                            const opacity = 0.3 + 0.7 * (elevation/maxElevation);
                            const r = Math.min(255, 92 + 163 * (elevation/maxElevation));
                            const g = Math.min(255, 187 - 92 * (elevation/maxElevation));
                            const b = Math.min(255, 246 - 160 * (elevation/maxElevation));
                            
                            segment.element.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                            segment.element.classList.add('elevated');
                            
                            isLineActive = true;
                        } else {
                            segment.element.style.transform = 'translateZ(0)';
                            segment.element.style.height = '1px';
                            segment.element.style.marginTop = '0';
                            segment.element.style.backgroundColor = 'rgba(92, 187, 246, 0.3)';
                            segment.element.classList.remove('elevated');
                        }
                    });
                    
                    if (isLineActive) {
                        line.element.classList.add('active');
                    } else {
                        line.element.classList.remove('active');
                    }
                });
                
                // Deforma i segmenti verticali
                verticalLines.forEach(line => {
                    let isLineActive = false;
                    
                    line.segments.forEach(segment => {
                        const dx = mouseX - segment.x;
                        const dy = mouseY - segment.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < influenceRadius) {
                            const elevation = calculateSphericalElevation(dx, dy, distance, influenceRadius);
                            const thickness = calculateLineThickness(elevation);
                            
                            // Applica la trasformazione 3D con spessore aumentato
                            segment.element.style.transform = `translateZ(${elevation}px)`;
                            segment.element.style.width = `${thickness}px`;
                            segment.element.style.marginLeft = `-${(thickness-1)/2}px`; // Centra la linea più spessa
                            
                            // Colore più intenso e luminoso
                            const opacity = 0.3 + 0.7 * (elevation/maxElevation);
                            const r = Math.min(255, 92 + 163 * (elevation/maxElevation));
                            const g = Math.min(255, 187 - 92 * (elevation/maxElevation));
                            const b = Math.min(255, 246 - 160 * (elevation/maxElevation));
                            
                            segment.element.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                            segment.element.classList.add('elevated');
                            
                            isLineActive = true;
                        } else {
                            segment.element.style.transform = 'translateZ(0)';
                            segment.element.style.width = '1px';
                            segment.element.style.marginLeft = '0';
                            segment.element.style.backgroundColor = 'rgba(92, 187, 246, 0.3)';
                            segment.element.classList.remove('elevated');
                        }
                    });
                    
                    if (isLineActive) {
                        line.element.classList.add('active');
                    } else {
                        line.element.classList.remove('active');
                    }
                });
            }
            
            // Funzione per gestire il movimento del mouse
            function handleMouseMove(e) {
                const rect = gridContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                isMouseOver = true;
                deformLines(mouseX, mouseY);
            }
            
            // Funzione per gestire l'entrata del mouse
            function handleMouseEnter() {
                isMouseOver = true;
            }
            
            // Funzione per gestire l'uscita del mouse
            function handleMouseLeave() {
                isMouseOver = false;
                
                // Resetta tutti i segmenti
                horizontalLines.forEach(line => {
                    line.element.classList.remove('active');
                    line.segments.forEach(segment => {
                        segment.element.style.transform = 'translateZ(0)';
                        segment.element.style.height = '1px';
                        segment.element.style.marginTop = '0';
                        segment.element.style.backgroundColor = 'rgba(92, 187, 246, 0.3)';
                        segment.element.classList.remove('elevated');
                    });
                });
                
                verticalLines.forEach(line => {
                    line.element.classList.remove('active');
                    line.segments.forEach(segment => {
                        segment.element.style.transform = 'translateZ(0)';
                        segment.element.style.width = '1px';
                        segment.element.style.marginLeft = '0';
                        segment.element.style.backgroundColor = 'rgba(92, 187, 246, 0.3)';
                        segment.element.classList.remove('elevated');
                    });
                });
            }
            
            // Aggiungi animazione pulsante quando non c'è interazione
            function addPulseAnimation() {
                let time = 0;
                const centerX = gridWidth / 2;
                const centerY = gridHeight / 2;
                
                function pulse() {
                    if (!isMouseOver) {
                        time += 0.02;
                        const pulseX = centerX + Math.sin(time) * 50;
                        const pulseY = centerY + Math.cos(time * 0.7) * 30;
                        
                        deformLines(pulseX, pulseY);
                    }
                    
                    requestAnimationFrame(pulse);
                }
                
                pulse();
            }
            
            // Crea la griglia iniziale
            createGrid();
            
            // Aggiungi event listeners
            window.addEventListener('resize', createGrid);
            gridContainer.addEventListener('mousemove', handleMouseMove);
            gridContainer.addEventListener('mouseenter', handleMouseEnter);
            gridContainer.addEventListener('mouseleave', handleMouseLeave);
            
            // Aggiungi animazione pulsante
            addPulseAnimation();
        });
    </script>
</body>
</html>
