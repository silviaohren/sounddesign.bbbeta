<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Illusion Grid</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1E1E2E;
            overflow: hidden;
        }
        
        .grid-container {
            position: relative;
            width: 600px;
            height: 300px;
            border: 1px solid rgba(92, 187, 246, 0.2);
            overflow: hidden;
            background-color: rgba(24, 24, 37, 0.8);
        }
        
        .line-segment {
            position: absolute;
            background-color: rgba(92, 187, 246, 0.4);
            transition: all 0.2s ease;
        }
        
        .horizontal-segment {
            height: 1px;
        }
        
        .vertical-segment {
            width: 1px;
        }
        
        .line-segment.active {
            background-color: rgba(255, 95, 86, 0.8);
            box-shadow: 0 0 4px rgba(255, 95, 86, 0.5);
        }
    </style>
</head>
<body>
    <div class="grid-container" id="gridContainer">
        <!-- I segmenti di linea verranno generati via JavaScript -->
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const gridContainer = document.getElementById('gridContainer');
            
            // Configurazione
            const lineSpacing = 20; // Spazio tra le linee
            const segmentLength = 20; // Lunghezza di ogni segmento
            const influenceRadius = 100; // Raggio di influenza del mouse
            const maxDisplacement = 20; // Spostamento massimo
            
            let horizontalSegments = [];
            let verticalSegments = [];
            let gridWidth, gridHeight;
            
            // Funzione per creare la griglia
            function createGrid() {
                // Pulisci la griglia esistente
                gridContainer.innerHTML = '';
                horizontalSegments = [];
                verticalSegments = [];
                
                // Ottieni le dimensioni del contenitore
                gridWidth = gridContainer.clientWidth;
                gridHeight = gridContainer.clientHeight;
                
                // Calcola il numero di linee orizzontali e verticali
                const numHorizontalLines = Math.floor(gridHeight / lineSpacing) + 1;
                const numVerticalLines = Math.floor(gridWidth / lineSpacing) + 1;
                
                // Crea i segmenti orizzontali
                for (let i = 0; i < numHorizontalLines; i++) {
                    const y = i * lineSpacing;
                    const lineSegments = [];
                    
                    // Dividi ogni linea in segmenti
                    for (let x = 0; x < gridWidth; x += segmentLength) {
                        const segment = document.createElement('div');
                        segment.className = 'line-segment horizontal-segment';
                        segment.style.left = `${x}px`;
                        segment.style.top = `${y}px`;
                        segment.style.width = `${Math.min(segmentLength, gridWidth - x)}px`;
                        
                        gridContainer.appendChild(segment);
                        
                        lineSegments.push({
                            element: segment,
                            x: x + segmentLength / 2, // centro del segmento
                            y: y,
                            width: Math.min(segmentLength, gridWidth - x),
                            originalY: y
                        });
                    }
                    
                    horizontalSegments.push(lineSegments);
                }
                
                // Crea i segmenti verticali
                for (let i = 0; i < numVerticalLines; i++) {
                    const x = i * lineSpacing;
                    const lineSegments = [];
                    
                    // Dividi ogni linea in segmenti
                    for (let y = 0; y < gridHeight; y += segmentLength) {
                        const segment = document.createElement('div');
                        segment.className = 'line-segment vertical-segment';
                        segment.style.left = `${x}px`;
                        segment.style.top = `${y}px`;
                        segment.style.height = `${Math.min(segmentLength, gridHeight - y)}px`;
                        
                        gridContainer.appendChild(segment);
                        
                        lineSegments.push({
                            element: segment,
                            x: x,
                            y: y + segmentLength / 2, // centro del segmento
                            height: Math.min(segmentLength, gridHeight - y),
                            originalX: x
                        });
                    }
                    
                    verticalSegments.push(lineSegments);
                }
            }
            
            // Funzione per calcolare lo spostamento basato sulla distanza
            function calculateDisplacement(distance) {
                if (distance >= influenceRadius) return 0;
                
                // Formula per creare un effetto a cupola
                const normalizedDistance = distance / influenceRadius;
                return maxDisplacement * Math.cos(normalizedDistance * Math.PI / 2);
            }
            
            // Funzione per deformare la griglia
            function deformGrid(mouseX, mouseY) {
                // Deforma i segmenti orizzontali
                horizontalSegments.forEach(lineSegments => {
                    lineSegments.forEach(segment => {
                        const dx = mouseX - segment.x;
                        const dy = mouseY - segment.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < influenceRadius) {
                            // Calcola lo spostamento verticale (effetto 3D)
                            const displacement = calculateDisplacement(distance);
                            
                            // Applica lo spostamento
                            segment.element.style.transform = `translateY(${-displacement}px)`;
                            
                            // Cambia l'opacità e il colore in base alla distanza
                            const opacity = 0.4 + 0.6 * (1 - distance / influenceRadius);
                            const r = Math.min(255, 92 + 163 * (1 - distance / influenceRadius));
                            const g = Math.min(255, 187 - 92 * (1 - distance / influenceRadius));
                            const b = Math.min(255, 246 - 160 * (1 - distance / influenceRadius));
                            
                            segment.element.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                            segment.element.classList.add('active');
                        } else {
                            segment.element.style.transform = '';
                            segment.element.style.backgroundColor = '';
                            segment.element.classList.remove('active');
                        }
                    });
                });
                
                // Deforma i segmenti verticali
                verticalSegments.forEach(lineSegments => {
                    lineSegments.forEach(segment => {
                        const dx = mouseX - segment.x;
                        const dy = mouseY - segment.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < influenceRadius) {
                            // Calcola lo spostamento orizzontale (effetto 3D)
                            const displacement = calculateDisplacement(distance);
                            
                            // Applica lo spostamento
                            segment.element.style.transform = `translateX(${-displacement}px)`;
                            
                            // Cambia l'opacità e il colore in base alla distanza
                            const opacity = 0.4 + 0.6 * (1 - distance / influenceRadius);
                            const r = Math.min(255, 92 + 163 * (1 - distance / influenceRadius));
                            const g = Math.min(255, 187 - 92 * (1 - distance / influenceRadius));
                            const b = Math.min(255, 246 - 160 * (1 - distance / influenceRadius));
                            
                            segment.element.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                            segment.element.classList.add('active');
                        } else {
                            segment.element.style.transform = '';
                            segment.element.style.backgroundColor = '';
                            segment.element.classList.remove('active');
                        }
                    });
                });
            }
            
            // Funzione per gestire il movimento del mouse
            function handleMouseMove(e) {
                const rect = gridContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                deformGrid(mouseX, mouseY);
            }
            
            // Funzione per gestire l'uscita del mouse
            function handleMouseLeave() {
                // Resetta tutti i segmenti
                horizontalSegments.forEach(lineSegments => {
                    lineSegments.forEach(segment => {
                        segment.element.style.transform = '';
                        segment.element.style.backgroundColor = '';
                        segment.element.classList.remove('active');
                    });
                });
                
                verticalSegments.forEach(lineSegments => {
                    lineSegments.forEach(segment => {
                        segment.element.style.transform = '';
                        segment.element.style.backgroundColor = '';
                        segment.element.classList.remove('active');
                    });
                });
            }
            
            // Crea la griglia iniziale
            createGrid();
            
            // Aggiungi event listeners
            window.addEventListener('resize', createGrid);
            gridContainer.addEventListener('mousemove', handleMouseMove);
            gridContainer.addEventListener('mouseleave', handleMouseLeave);
        });
    </script>
</body>
</html>
